## 重点

- 被用到的数据就是依赖，在 getter 中收集依赖的订阅者（观察者，即 watchers），在 setter 中触发依赖之前收集的订阅者
- dep 数组用来收集和管理依赖的订阅者
- 数据变化时（依赖变化时），对应依赖的 setter 就通知它的 dep，让 dep 激活它管理的全部 watcher，以实现特定的功能（比如更新对应的视图）
- 当前激活的 watcher 把自己放到全局的某个位置，比如 Dep.target，以便被其他需要的依赖收集

## 响应式化的基本流程

observe（响应式化一个数据对象） -> Observer（遍历此对象） -> defineReactive（劫持此对象的每个数据） -> observe（递归子对象） ...

## 其他

Vue1.x 的响应式更新以 dom 节点为单位进行更新，在渲染模板时遇到插值表达式或指令就会实例化对应的 watcher，这是一种细粒度的更新，而 Vue2.x 以组件为单位进行更新，传入 watcher 的不再是表达式字符串而是组件对应的渲染函数，这是一种中粒度的更新。
Vue1.x 的细颗粒更新的主要缺点：

1. 无法支撑大型应用，因为依赖越多需要的 watcher 实例越多，还包括其他用户自定义的 watcher（watch 和 computed），造成大量的内存消耗
2. 由于操作的都是 dom 对象，也仅支持 web 端

在 Vue2.x 中，更新以组件为单位，一个组件只有一个渲染 watcher，每个依赖的 dep 都收集了此渲染 watcher，此渲染 watcher 产生此组件的虚拟 dom，在组件内对新旧虚拟 dom 进行 diff 比较（使用的是 snabbdom 这款虚拟 dom 引擎），最终将有差异的部分 patch 到此组件引用的真实 dom 上，从而有效地解决了 Vue1.x 的 2 个主要缺点：

1. 每个依赖不再有自己独立的 watcher，而是都收集了同一个渲染 watcher
2. 引入了虚拟 dom，使得跨平台得到了保证
